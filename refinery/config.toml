#####################
## Refinery Config ##
#####################

# ListenAddr is the IP and port on which to listen for incoming events. Incoming
# traffic is expected to be HTTP, so if using SSL put something like nginx in
# front to do the decryption.
# Should be of the form 0.0.0.0:8080
# Not eligible for live reload.
ListenAddr = "{{ .Values.config.ListenAddr }}"

# PeerListenAddr is the IP and port on which to listen for traffic being
# rerouted from a peer. Peer traffic is expected to be HTTP, so if using SSL
# put something like nginx in front to do the decryption. Must be different from
# ListenAddr
# Should be of the form 0.0.0.0:8081
# Not eligible for live reload.
PeerListenAddr = "{{ .Values.config.PeerListenAddr }}"

# APIKeys is a list of Honeycomb API keys that the proxy will accept. This list
# only applies to events - other Honeycomb API actions will fall through to the
# upstream API directly.
# Adding keys here causes events arriving with API keys not in this list to be
# rejected with an HTTP 401 error If an API key that is a literal '*' is in the
# list, all API keys are accepted.
# Eligible for live reload.
APIKeys = [
	# "replace-me",
	# "more-optional-keys",
	"*",                   # wildcard accept all keys
	]

# HoneycombAPI is the URL for the upstream Honeycomb API.
# Eligible for live reload.
HoneycombAPI = "{{ .Values.config.HoneycombAPI }}"

# SendDelay is a short timer that will be triggered when a trace is complete.
# Refinery will wait this duration before actually sending the trace.  The
# reason for this short delay is to allow for small network delays or clock
# jitters to elapse and any final spans to arrive before actually sending the
# trace.  This supports duration strings with supplied units. Set to 0 for
# immediate sends.
# Eligible for live reload.
SendDelay = "{{ .Values.config.SendDelay }}"

# TraceTimeout is a long timer; it represents the outside boundary of how long
# to wait before sending an incomplete trace. Normally traces are sent when the
# root span arrives. Sometimes the root span never arrives (due to crashes or
# whatever), and this timer will send a trace even without having received the
# root span. If you have particularly long-lived traces you should increase this
# timer. This supports duration strings with supplied units.
# Eligible for live reload.
TraceTimeout = "{{ .Values.config.TraceTimeout }}"

# SendTicker is a short timer; it determines the duration to use to check for traces to send
SendTicker = "{{ .Values.config.SendTicker }}"

# LoggingLevel is the level above which we should log. Debug is very verbose,
# and should only be used in pre-production environments. Info is the
# recommended level. Valid options are "debug", "info", "error", and
# "panic"
# Not eligible for live reload.
LoggingLevel = "{{ .Values.config.LoggingLevel }}"

# UpstreamBufferSize and PeerBufferSize control how large of an event queue to use
# when buffering events that will be forwarded to peers or the upstream API.
UpstreamBufferSize = {{ .Values.config.UpstreamBufferSize }}
PeerBufferSize = {{ .Values.config.PeerBufferSize }}

# DebugServiceAddr sets the IP and port the debug service will run on
# The debug service will only run if the command line flag -d is specified
# The debug service runs on the first open port between localhost:6060 and :6069 by default
# DebugServiceAddr = "localhost:8085"

############################
## Implementation Choices ##
############################

# Each of the config options below chooses an implementation of a Refinery
# component to use. Depending on the choice there may be more configuration
# required below in the section for that choice. Changing implementation choices
# requires a process restart; these changes will not be picked up by a live
# config reload. (Individual config options for a given implementation may be
# eligible for live reload).

# Collector describes which collector to use for collecting traces. The only
# current valid option is "InMemCollector".. More can be added by adding
# implementations of the Collector interface.
Collector = "InMemCollector"

# Logger describes which logger to use for Refinery logs. Valid options are
# "logrus" and "honeycomb". The logrus option will write logs to STDOUT and the
# honeycomb option will send them to a Honeycomb dataset.
Logger = "{{ .Values.config.Logger }}"

# Metrics describes which service to use for Refinery metrics. Valid options are
# "prometheus" and "honeycomb". The prometheus option starts a listener that
# will reply to a request for /metrics. The honeycomb option will send summary
# metrics to a Honeycomb dataset.
Metrics = "{{ .Values.config.Metrics }}"

#####################
## Peer Management ##
#####################

[PeerManagement]

Type = "redis"

# RedisHost is is used to connect to redis for peer cluster membership management.
# Further, if the environment variable 'REFINERY_REDIS_HOST' is set it takes
# precedence and this value is ignored.
# Not eligible for live reload.
RedisHost = "{{ if .Values.redis.existingHost }}{{ .Values.redis.existingHost | quote }}{{ else }}{{ include "refinery.redis.fullname" . }}:6379{{ end }}"

# IdentifierInterfaceName is optional. By default, when using RedisHost, Refinery will use
# the local hostname to identify itself to other peers in Redis. If your environment
# requires that you use IPs as identifiers (for example, if peers can't resolve eachother
# by name), you can specify the network interface that Refinery is listening on here.
# Refinery will use the first unicast address that it finds on the specified network
# interface as its identifier.
# Not eligible for live reload.
IdentifierInterfaceName = "eth0"

#########################
## In-Memory Collector ##
#########################

# InMemCollector brings together all the settings that are relevant to
# collecting spans together to make traces.
[InMemCollector]

# The collection cache is used to collect all spans into a trace as well as
# remember the sampling decision for any spans that might come in after the
# trace has been marked "complete" (either by timing out or seeing the root
# span). The number of traces in the cache should be many multiples (100x to
# 1000x) of the total number of concurrently active traces (trace throughput *
# trace duration).
# Eligible for live reload. Growing the cache capacity with a live config reload
# is fine. Avoid shrinking it with a live reload (you can, but it may cause
# temporary odd sampling decisions).
CacheCapacity = {{ .Values.config.InMemCollector.CacheCapacity }}

# MaxAlloc is optional. If set, it must be an integer >= 0. 64-bit values are
# supported.
# If set to a non-zero value, once per tick (see SendTicker) the collector
# will compare total allocated bytes to this value. If allocation is too
# high, cache capacity will be reduced and an error will be logged.
# Useful values for this setting are generally in the range of 75%-90% of
# available system memory.
MaxAlloc = {{ .Values.config.InMemCollector.MaxAlloc }}


{{- if eq .Values.config.Logger "honeycomb" }}
######################
## Honeycomb Logger ##
######################

# HoneycombLogger is a section of the config only used if you are using the
# HoneycombLogger to send all logs to a Honeycomb Dataset. If you are using a
# different logger (eg file-based logger) you can leave all this commented out.

[HoneycombLogger]

# LoggerHoneycombAPI is the URL for the upstream Honeycomb API.
# Eligible for live reload.
LoggerHoneycombAPI = "{{ .Values.config.HoneycombLogger.LoggerHoneycombAPI }}"

# LoggerAPIKey is the API key to use to send log events to the Honeycomb logging
# dataset. This is separate from the APIKeys used to authenticate regular
# traffic.
# Eligible for live reload.
LoggerAPIKey = "{{ .Values.config.HoneycombLogger.LoggerAPIKey }}"

# LoggerDataset is the name of the dataset to which to send Refinery logs
# Eligible for live reload.
LoggerDataset = "{{ .Values.config.HoneycombLogger.LoggerDataset }}"

{{- else if eq .Values.config.Logger "logrus" }}
###################
## Logrus Logger ##
###################

# LogrusLogger is a section of the config only used if you are using the
# LogrusLogger to send all logs to STDOUT using the logrus package. If you are
# using a different logger (eg honeycomb logger) you can leave all this
# commented out.
[LogrusLogger]

# logrus logger currently has no options!
{{- end }}


{{- if eq .Values.config.Metrics "honeycomb" }}
#######################
## Honeycomb Metrics ##
#######################

# HoneycombMetrics is a section of the config only used if you are using the
# HoneycombMetrics to send all metrics to a Honeycomb Dataset. If you are using a
# different metrics service (eg prometheus or metricsd) you can leave all this
# commented out.

[HoneycombMetrics]

# MetricsHoneycombAPI is the URL for the upstream Honeycomb API.
# Eligible for live reload.
MetricsHoneycombAPI = "{{ .Values.config.HoneycombMetrics.MetricsHoneycombAPI }}"

# MetricsAPIKey is the API key to use to send log events to the Honeycomb logging
# dataset. This is separate from the APIKeys used to authenticate regular
# traffic.
# Eligible for live reload.
MetricsAPIKey = "{{ .Values.config.HoneycombMetrics.MetricsAPIKey }}"

# MetricsDataset is the name of the dataset to which to send Refinery metrics
# Eligible for live reload.
MetricsDataset = "{{ .Values.config.HoneycombMetrics.MetricsDataset }}"

# MetricsReportingInterval is the frequency (in seconds) to send metric events
# to Honeycomb. Between 1 and 60 is recommended.
# Not eligible for live reload.
MetricsReportingInterval = {{ .Values.config.HoneycombMetrics.MetricsReportingInterval }}

{{- else if eq .Values.config.Metrics "prometheus" }}
########################
## Prometheus Metrics ##
########################

[PrometheusMetrics]

# MetricsListenAddr determines the interface and port on which Prometheus will
# listen for requests for /metrics. Must be different from the main Refinery
# listener.
# Not eligible for live reload.
MetricsListenAddr = "0.0.0.0:9090"
{{- end }}